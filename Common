using System;
using System.IO;
using System.Net.Http;
using System.Threading.Tasks;
using WebSocketSharp;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace QlikSenseChartDataExtractor
{
    class Program
    {
        // Configuration
        private static readonly string WS_URL = "ws://localhost:4848/app/"; // For Qlik Sense Desktop
        private static readonly string APP_NAME = "YourApp.qvf"; // Replace with your app name (e.g., "Executive Dashboard.qvf")
        private static readonly string CHART_ID = "kfxNpV"; // Replace with your chart ID
        private static readonly string OUTPUT_CSV = "chart_data.csv"; // Output CSV file

        // Global variables
        private static int appHandle = -1;
        private static int sessionHandle = -1;
        private static int chartHandle = -1;
        private static int hypercubeHandle = -1;
        private static int messageId = 1;
        private static readonly JObject responses = new JObject();
        private static WebSocket ws;

        static async Task Main(string[] args)
        {
            try
            {
                // Initialize WebSocket
                ws = new WebSocket(WS_URL);
                ws.OnMessage += OnMessage;
                ws.OnError += (sender, e) => Console.WriteLine($"WebSocket error: {e.Message}");
                ws.OnOpen += (sender, e) => Console.WriteLine("Connected to Qlik Engine");
                ws.OnClose += (sender, e) => Console.WriteLine("WebSocket connection closed");

                // Connect to WebSocket
                ws.Connect();

                // Wait for processing to complete (simplified; adjust for production)
                await Task.Delay(TimeSpan.FromSeconds(10));

                // Close WebSocket
                ws.Close();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error: {ex.Message}");
            }
        }

        private static void OnMessage(object sender, MessageEventArgs e)
        {
            var response = JObject.Parse(e.Data);
            Console.WriteLine($"Received response ID {response["id"]}: {response.ToString(Formatting.Indented)}");
            responses[response["id"].ToString()] = response;

            switch ((int)response["id"])
            {
                case 1: // GetDocList
                    HandleGetDocList(response);
                    break;
                case 2: // OpenDoc
                    HandleOpenDoc(response);
                    break;
                case 3: // CreateSessionObject (SheetList)
                    HandleCreateSessionObjectSheetList(response);
                    break;
                case 4: // GetLayout (SheetList)
                    HandleGetSheetLayout(response);
                    break;
                case 5: // GetObject (Chart)
                    HandleGetObject(response);
                    break;
                case 6: // GetLayout (Chart)
                    HandleGetChartLayout(response);
                    break;
                case 7: // CreateSessionObject (HyperCube)
                    HandleCreateSessionObjectHyperCube(response);
                    break;
                case 8: // GetLayout (HyperCube)
                    HandleGetHyperCubeLayout(response);
                    break;
                case 9: // ExportData
                    HandleExportData(response);
                    break;
            }
        }

        private static void SendRequest(JObject request)
        {
            request["id"] = messageId++;
            ws.Send(request.ToString());
        }

        private static void HandleGetDocList(JObject response)
        {
            foreach (var doc in response["result"]["qDocList"])
            {
                if (doc["qDocName"].ToString() == APP_NAME)
                {
                    var appId = doc["qDocId"].ToString();
                    SendRequest(new JObject
                    {
                        ["jsonrpc"] = "2.0",
                        ["id"] = messageId,
                        ["handle"] = -1,
                        ["method"] = "OpenDoc",
                        ["params"] = new JArray(appId)
                    });
                    break;
                }
            }
        }

        private static void HandleOpenDoc(JObject response)
        {
            appHandle = response["result"]["qReturn"]["qHandle"].ToObject<int>();
            SendRequest(new JObject
            {
                ["jsonrpc"] = "2.0",
                ["id"] = messageId,
                ["handle"] = appHandle,
                ["method"] = "CreateSessionObject",
                ["params"] = new JArray(new JObject
                {
                    ["qInfo"] = new JObject { ["qType"] = "SheetList" },
                    ["qAppObjectListDef"] = new JObject
                    {
                        ["qType"] = "sheet",
                        ["qData"] = new JObject { ["cells"] = "/cells" }
                    }
                })
            });
        }

        private static void HandleCreateSessionObjectSheetList(JObject response)
        {
            sessionHandle = response["result"]["qReturn"]["qHandle"].ToObject<int>();
            SendRequest(new JObject
            {
                ["jsonrpc"] = "2.0",
                ["id"] = messageId,
                ["handle"] = sessionHandle,
                ["method"] = "GetLayout",
                ["params"] = new JArray()
            });
        }

        private static void HandleGetSheetLayout(JObject response)
        {
            var sheets = response["result"]["qLayout"]["qAppObjectList"]["qItems"];
            foreach (var sheet in sheets)
            {
                foreach (var cell in sheet["qData"]["cells"])
                {
                    Console.WriteLine($"Chart ID: {cell["name"]}, Type: {cell["type"]}");
                }
            }
            SendRequest(new JObject
            {
                ["jsonrpc"] = "2.0",
                ["id"] = messageId,
                ["handle"] = appHandle,
                ["method"] = "GetObject",
                ["params"] = new JArray(CHART_ID)
            });
        }

        private static void HandleGetObject(JObject response)
        {
            chartHandle = response["result"]["qReturn"]["qHandle"].ToObject<int>();
            SendRequest(new JObject
            {
                ["jsonrpc"] = "2.0",
                ["id"] = messageId,
                ["handle"] = chartHandle,
                ["method"] = "GetLayout",
                ["params"] = new JArray()
            });
        }

        private static void HandleGetChartLayout(JObject response)
        {
            var hyperCubeDef = response["result"]["qLayout"]["qHyperCubeDef"];
            var dimensions = hyperCubeDef["qDimensions"];
            var measures = hyperCubeDef["qMeasures"];
            var width = dimensions.Count() + measures.Count();
            SendRequest(new JObject
            {
                ["jsonrpc"] = "2.0",
                ["id"] = messageId,
                ["handle"] = appHandle,
                ["method"] = "CreateSessionObject",
                ["params"] = new JArray(new JObject
                {
                    ["qInfo"] = new JObject { ["qType"] = "HyperCube" },
                    ["qHyperCubeDef"] = new JObject
                    {
                        ["qDimensions"] = dimensions,
                        ["qMeasures"] = measures,
                        ["qInitialDataFetch"] = new JArray(new JObject
                        {
                            ["qTop"] = 0,
                            ["qLeft"] = 0,
                            ["qHeight"] = 1000,
                            ["qWidth"] = width
                        })
                    }
                })
            });
        }

        private static void HandleCreateSessionObjectHyperCube(JObject response)
        {
            hypercubeHandle = response["result"]["qReturn"]["qHandle"].ToObject<int>();
            SendRequest(new JObject
            {
                ["jsonrpc"] = "2.0",
                ["id"] = messageId,
                ["handle"] = hypercubeHandle,
                ["method"] = "GetLayout",
                ["params"] = new JArray()
            });
        }

        private static void HandleGetHyperCubeLayout(JObject response)
        {
            var hyperCube = response["result"]["qLayout"]["qHyperCube"];
            var dimensions = hyperCube["qDimensionInfo"].Select(d => d["qFallbackTitle"].ToString()).ToList();
            var measures = hyperCube["qMeasureInfo"].Select(m => m["qFallbackTitle"].ToString() ?? m["qDef"].ToString()).ToList();
            var data = hyperCube["qDataPages"][0]["qMatrix"];

            // Write to CSV
            using (var writer = new StreamWriter(OUTPUT_CSV))
            {
                // Write header
                writer.WriteLine(string.Join(",", dimensions.Concat(measures)));
                // Write data rows
                foreach (var row in data)
                {
                    var rowData = row.Select(cell => cell["qText"].ToString());
                    writer.WriteLine(string.Join(",", rowData));
                }
            }
            Console.WriteLine($"Chart data saved to {OUTPUT_CSV}");

            // Export data as CSV
            SendRequest(new JObject
            {
                ["jsonrpc"] = "2.0",
                ["id"] = messageId,
                ["handle"] = chartHandle,
                ["method"] = "ExportData",
                ["params"] = new JArray("CSV_C")
            });
        }

        private static async void HandleExportData(JObject response)
        {
            var exportUrl = "http://localhost:4848" + response["result"]["qUrl"].ToString();
            using (var client = new HttpClient())
            {
                var responseData = await client.GetAsync(exportUrl);
                var content = await responseData.Content.ReadAsByteArrayAsync();
                File.WriteAllBytes("exported_chart_data.csv", content);
                Console.WriteLine("Exported chart data saved to exported_chart_data.csv");
            }
        }
    }
}










// QlikChartRepository.cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Npgsql;

namespace QlikDashboardbackend.Data
{
    public class QlikChartRepository
    {
        private readonly string _connectionString;

        public QlikChartRepository(string connectionString)
        {
            _connectionString = connectionString;
        }

        public async Task SaveChartDataAsync(string chartId, string qText, double? qNum, string layoutJson)
        {
            using var conn = new NpgsqlConnection(_connectionString);
            await conn.OpenAsync();

            var cmd = new NpgsqlCommand(
                @"INSERT INTO QlikChartData (ChartId, QText, QNum, LayoutJson, CreatedAt) 
                  VALUES (@chartId, @qText, @qNum, @layoutJson, NOW())", conn);

            cmd.Parameters.AddWithValue("chartId", chartId);
            cmd.Parameters.AddWithValue("qText", (object)qText ?? DBNull.Value);
            cmd.Parameters.AddWithValue("qNum", (object)qNum ?? DBNull.Value);
            cmd.Parameters.AddWithValue("layoutJson", layoutJson ?? "");

            await cmd.ExecuteNonQueryAsync();
        }

        public async Task<IEnumerable<dynamic>> GetLatestChartDataAsync()
        {
            using var conn = new NpgsqlConnection(_connectionString);
            await conn.OpenAsync();

            var cmd = new NpgsqlCommand(
                "SELECT ChartId, QText, QNum, LayoutJson, CreatedAt FROM QlikChartData ORDER BY CreatedAt DESC", conn);

            using var reader = await cmd.ExecuteReaderAsync();

            var list = new List<dynamic>();
            while (await reader.ReadAsync())
            {
                list.Add(new
                {
                    ChartId = reader["ChartId"].ToString(),
                    QText = reader["QText"].ToString(),
                    QNum = reader["QNum"] != DBNull.Value ? Convert.ToDouble(reader["QNum"]) : (double?)null,
                    LayoutJson = reader["LayoutJson"].ToString(),
                    CreatedAt = Convert.ToDateTime(reader["CreatedAt"])
                });
            }
            return list;
        }
    }
}








// QlikDataExtractor.cs
using System;
using System.Text.Json;
using System.Threading.Tasks;
using QlikDashboardbackend.Data;

namespace QlikDashboardbackend.Services
{
    public class QlikDataExtractor
    {
        private readonly QlikChartRepository _qlikChartRepository;

        public QlikDataExtractor(QlikChartRepository qlikChartRepository)
        {
            _qlikChartRepository = qlikChartRepository;
        }

        /// <summary>
        /// Extracts qText, qNum, and layout JSON from raw Qlik API response and saves to DB.
        /// </summary>
        /// <param name="chartId"></param>
        /// <param name="rawJson"></param>
        public async Task ExtractAndStoreAsync(string chartId, string rawJson)
        {
            if (string.IsNullOrWhiteSpace(rawJson))
                throw new ArgumentException("rawJson cannot be null or empty");

            using var doc = JsonDocument.Parse(rawJson);
            var root = doc.RootElement;

            // Extract layout JSON if present, else empty object
            string layoutJson = root.TryGetProperty("layout", out var layoutElement)
                ? layoutElement.GetRawText()
                : "{}";

            // Extract qMatrix data from qHyperCubeData
            if (!root.TryGetProperty("qHyperCubeData", out var hyperCubeData) ||
                !hyperCubeData.TryGetProperty("qMatrix", out var qMatrix))
            {
                // No hypercube data found, nothing to save
                return;
            }

            foreach (var row in qMatrix.EnumerateArray())
            {
                foreach (var cell in row.EnumerateArray())
                {
                    string qText = cell.TryGetProperty("qText", out var qTextProp)
                        ? qTextProp.GetString()
                        : null;

                    double? qNum = null;
                    if (cell.TryGetProperty("qNum", out var qNumProp) && qNumProp.ValueKind == JsonValueKind.Number)
                    {
                        qNum = qNumProp.GetDouble();
                    }

                    // Save extracted data point to DB
                    await _qlikChartRepository.SaveChartDataAsync(chartId, qText, qNum, layoutJson);
                }
            }
        }
    }
}







using QlikDashboardbackend.Data;
using QlikDashboardbackend.Services;
using System.Collections.Generic;
using System.Security.Cryptography.X509Certificates;
using System.Threading.Tasks;

namespace QlikDashboardbackend.Services
{
    public class QlikProcessor
    {
        private readonly QlikChartRepository _repository;
        private readonly QlikDataExtractor _extractor;

        public QlikProcessor(string connectionString)
        {
            _repository = new QlikChartRepository(connectionString);
            _extractor = new QlikDataExtractor(_repository);
        }

        public async Task<List<object>> RunAsync()
        {
            string appId = "your-app-id";
            List<string> objectIds = new List<string> { "id1", "id2", "id3" };

            var clientCert = new X509Certificate2("path-to-cert.pfx", "cert-password");
            var handler = new ClientWebSocketHandler(clientCert, "UserDirectory=INTERNAL; UserId=sa_engine");

            List<object> results = new List<object>();

            using var ws = await handler.ConnectAsync(new Uri($"wss://your-qlik-server:4747/app/{appId}"));

            foreach (var objectId in objectIds)
            {
                string rawJson = await QlikCert.SendEngineRequest(ws, appId, objectId);

                // Save parsed data to DB
                await _extractor.ExtractAndStoreAsync(objectId, rawJson);

                results.Add(rawJson); // or some summary data if needed
            }

            return results;
        }
    }


}












using Microsoft.AspNetCore.Mvc;
using System;
using System.Threading.Tasks;
using QlikDashboardbackend.Services;

namespace QlikDashboardbackend.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class QlikController : ControllerBase
    {
        private readonly string _connectionString = "Host=localhost;Database=your_db;Username=your_user;Password=your_pass";

        [HttpPost("process")]
        public async Task<IActionResult> ProcessQlikData()
        {
            try
            {
                var processor = new QlikProcessor(_connectionString);
                var results = await processor.RunAsync();

                return Ok(new
                {
                    Success = true,
                    Message = "Qlik data processed and saved to DB.",
                    Results = results
                });
            }
            catch (Exception ex)
            {
                return StatusCode(500, new
                {
                    Success = false,
                    Error = ex.Message
                });
            }
        }
    }
}



















using Microsoft.AspNetCore.Mvc;
using System;
using System.Threading.Tasks;
using QlikDashboardbackend.Services;
using QlikDashboardbackend.Data;

namespace QlikDashboardbackend.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class QlikController : ControllerBase
    {
        private readonly string _connectionString = "Host=localhost;Database=your_db;Username=your_user;Password=your_pass";

        /// <summary>
        /// POST - Extracts Qlik chart data and stores it in DB
        /// </summary>
        [HttpPost("process")]
        public async Task<IActionResult> ProcessQlikData()
        {
            try
            {
                var processor = new QlikProcessor(_connectionString);
                var results = await processor.RunAsync();

                return Ok(new
                {
                    Success = true,
                    Message = "Qlik data processed and saved to DB.",
                    Results = results
                });
            }
            catch (Exception ex)
            {
                return StatusCode(500, new
                {
                    Success = false,
                    Error = ex.Message
                });
            }
        }

        /// <summary>
        /// GET - Returns latest chart data from DB
        /// </summary>
        [HttpGet("latest")]
        public async Task<IActionResult> GetLatestChartData()
        {
            try
            {
                var repository = new QlikChartRepository(_connectionString);
                var latestData = await repository.GetLatestChartDataAsync();

                return Ok(new
                {
                    Success = true,
                    Data = latestData
                });
            }
            catch (Exception ex)
            {
                return StatusCode(500, new
                {
                    Success = false,
                    Error = ex.Message
                });
            }
        }
    }
}
















using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Configuration;
using System;
using System.Threading.Tasks;
using QlikDashboardbackend.Services;
using QlikDashboardbackend.Data;

namespace QlikDashboardbackend.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class QlikController : ControllerBase
    {
        private readonly string _connectionString;

        public QlikController(IConfiguration configuration)
        {
            _connectionString = configuration.GetConnectionString("PostgresDb");
        }

        [HttpPost("process")]
        public async Task<IActionResult> ProcessQlikData()
        {
            try
            {
                var processor = new QlikProcessor(_connectionString);
                var results = await processor.RunAsync();

                return Ok(new
                {
                    Success = true,
                    Message = "Qlik data processed and saved to DB.",
                    Results = results
                });
            }
            catch (Exception ex)
            {
                return StatusCode(500, new
                {
                    Success = false,
                    Error = ex.Message
                });
            }
        }

        [HttpGet("latest")]
        public async Task<IActionResult> GetLatestChartData()
        {
            try
            {
                var repository = new QlikChartRepository(_connectionString);
                var latestData = await repository.GetLatestChartDataAsync();

                return Ok(new
                {
                    Success = true,
                    Data = latestData
                });
            }
            catch (Exception ex)
            {
                return StatusCode(500, new
                {
                    Success = false,
                    Error = ex.Message
                });
            }
        }
    }
}









using System.Net.Http;
using System.Threading.Tasks;
using Newtonsoft.Json.Linq;
using System.Collections.Generic;

namespace QlikDashboardbackend.Helpers
{
    public class QlikHyperCubeHelper
    {
        private readonly HttpClient _httpClient;

        public QlikHyperCubeHelper(HttpClient httpClient)
        {
            _httpClient = httpClient;
        }

        // Model for clean output
        public class HyperCubeData
        {
            public string QText { get; set; }
            public double? QNum { get; set; }
        }

        // Fetch & process data from Swagger process endpoint
        public async Task<List<HyperCubeData>> GetProcessedDataAsync(string processUrl)
        {
            var response = await _httpClient.GetStringAsync(processUrl);

            var json = JObject.Parse(response);

            var dataMatrix = json["qHyperCube"]?["qDataPages"]?[0]?["qMatrix"];
            var result = new List<HyperCubeData>();

            if (dataMatrix != null)
            {
                foreach (var row in dataMatrix)
                {
                    string qText = row[0]?["qText"]?.ToString();
                    double? qNum = row[0]?["qNum"]?.ToObject<double?>();

                    result.Add(new HyperCubeData { QText = qText, QNum = qNum });
                }
            }

            // log in console for testing
            Console.WriteLine("=== Extracted HyperCube Data ===");
            foreach (var item in result)
            {
                Console.WriteLine($"qText: {item.QText}, qNum: {item.QNum}");
            }

            return result;
        }





    }
}








terraform.tf 


terraform {
  required_version = ">= 1.5.0"

  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 5.0"
    }
  }
}

provider "google" {
  project = var.project_id
  region  = var.region
  zone    = var.zone
}




auto


project_id              = "hsbc-8887838-mssbi-dev"
region                  = "europe-west2"
zone                    = "europe-west2-b"
instance_name           = "looker-training-db"
db_version              = "MYSQL_8_0"
tier                    = "db-custom-2-7680"
disk_size               = 100
disk_autoresize         = true
availability_type       = "ZONAL"
network                 = "hsbc-default-network"
backup_location         = "europe-west2"
psc_projects            = ["hsbc-8887838-mssbi-dev"]
kms_key_name            = "projects/hsbc-6320774-kms-dev/locations/europe-west2/keyRings/sql/cryptoKeys/sqlsharedkey"
labels = {
  purpose = "looker_training"
}




variables.tf 


variable "project_id" {
  type        = string
  description = "GCP project ID"
}

variable "region" {
  type        = string
  description = "GCP region"
}

variable "zone" {
  type        = string
  description = "GCP zone"
}

variable "instance_name" {
  type        = string
  description = "Cloud SQL instance name"
}

variable "db_version" {
  type        = string
  description = "Database version"
  default     = "MYSQL_8_0"
}

variable "tier" {
  type        = string
  description = "Machine type tier (e.g., db-custom-2-7680)"
}

variable "disk_size" {
  type        = number
  default     = 100
}

variable "disk_autoresize" {
  type        = bool
  default     = true
}

variable "availability_type" {
  type        = string
  default     = "ZONAL"
}

variable "network" {
  type        = string
  description = "VPC network name"
}

variable "backup_location" {
  type        = string
}

variable "psc_projects" {
  type        = list(string)
  description = "Allowed PSC projects"
}

variable "kms_key_name" {
  type        = string
  description = "CMEK key for encryption"
}

variable "labels" {
  type        = map(string)
  default     = {}
}




main.tf 

module "cloudsql" {
  source = "./modules/cloudsql"

  project_id        = var.project_id
  region            = var.region
  zone              = var.zone
  instance_name     = var.instance_name
  db_version        = var.db_version
  tier              = var.tier
  disk_size         = var.disk_size
  disk_autoresize   = var.disk_autoresize
  availability_type = var.availability_type
  network           = var.network
  backup_location   = var.backup_location
  psc_projects      = var.psc_projects
  kms_key_name      = var.kms_key_name
  labels            = var.labels
}




modulemain 


resource "google_sql_database_instance" "default" {
  name             = var.instance_name
  project          = var.project_id
  region           = var.region
  database_version = var.db_version

  settings {
    tier              = var.tier
    availability_type = var.availability_type
    disk_size         = var.disk_size
    disk_autoresize   = var.disk_autoresize

    ip_configuration {
      ipv4_enabled      = false
      private_network   = "projects/${var.project_id}/global/networks/${var.network}"
      psc_config {
        allowed_consumer_projects = var.psc_projects
      }
    }

    backup_configuration {
      enabled            = true
      location           = var.backup_location
      point_in_time_recovery_enabled = true
    }

    database_flags {
      name  = "cloudsql_iam_authentication"
      value = "on"
    }
    database_flags {
      name  = "general_log"
      value = "on"
    }
    database_flags {
      name  = "log_output"
      value = "TABLE"
    }
  }

  deletion_protection = false

  encryption_key_name = var.kms_key_name

  labels = var.labels
}





varibles 


variable "project_id" {
  type        = string
  description = "GCP project ID"
}

variable "region" {
  type        = string
  description = "GCP region"
}

variable "zone" {
  type        = string
  description = "GCP zone"
}

variable "instance_name" {
  type        = string
  description = "Cloud SQL instance name"
}

variable "db_version" {
  type        = string
  description = "Database version (MYSQL_8_0, POSTGRES_14, etc.)"
  default     = "MYSQL_8_0"
}

variable "tier" {
  type        = string
  description = "Machine type tier (e.g., db-custom-2-7680 for 2 vCPU, 7680MB RAM)"
}

variable "disk_size" {
  type        = number
  default     = 100
  description = "Disk size in GB"
}

variable "disk_autoresize" {
  type        = bool
  default     = true
  description = "Whether to enable disk auto-resize"
}

variable "availability_type" {
  type        = string
  default     = "ZONAL"
  description = "Availability type: ZONAL or REGIONAL"
}

variable "network" {
  type        = string
  description = "VPC network name"
}

variable "backup_location" {
  type        = string
  description = "Location for backups (must be a valid GCP region)"
}

variable "psc_projects" {
  type        = list(string)
  description = "List of allowed PSC consumer projects"
}

variable "kms_key_name" {
  type        = string
  description = "CMEK key resource ID for encryption"
}

variable "labels" {
  type        = map(string)
  default     = {}
  description = "Labels to assign to the instance"
}


/* Flex container for the charts */
.dashboard-container {
  display: flex;
  flex-wrap: wrap;       /* allow wrapping to next row */
  gap: 20px;             /* space between boxes */
  justify-content: center;
  padding: 20px;
  box-sizing: border-box;
}

/* Each chart box */
.chart-box {
  flex: 0 1 calc(50% - 20px);  /* 2 charts per row */
  max-width: calc(50% - 20px);
  height: 400px;
  background-color: #ffffff;
  border: 1px solid #ddd;
  border-radius: 8px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  display: flex;
  flex-direction: column;  /* title above chart */
  justify-content: flex-start;
  align-items: center;
  padding: 20px;
  box-sizing: border-box;
}

/* Chart title */
.chart-title {
  text-align: center;
  font-size: 1.5rem;
  font-weight: bold;
  margin-bottom: 15px;
  color: #299185;
}










