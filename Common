using System;
using System.IO;
using System.Net.Http;
using System.Threading.Tasks;
using WebSocketSharp;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace QlikSenseChartDataExtractor
{
    class Program
    {
        // Configuration
        private static readonly string WS_URL = "ws://localhost:4848/app/"; // For Qlik Sense Desktop
        private static readonly string APP_NAME = "YourApp.qvf"; // Replace with your app name (e.g., "Executive Dashboard.qvf")
        private static readonly string CHART_ID = "kfxNpV"; // Replace with your chart ID
        private static readonly string OUTPUT_CSV = "chart_data.csv"; // Output CSV file

        // Global variables
        private static int appHandle = -1;
        private static int sessionHandle = -1;
        private static int chartHandle = -1;
        private static int hypercubeHandle = -1;
        private static int messageId = 1;
        private static readonly JObject responses = new JObject();
        private static WebSocket ws;

        static async Task Main(string[] args)
        {
            try
            {
                // Initialize WebSocket
                ws = new WebSocket(WS_URL);
                ws.OnMessage += OnMessage;
                ws.OnError += (sender, e) => Console.WriteLine($"WebSocket error: {e.Message}");
                ws.OnOpen += (sender, e) => Console.WriteLine("Connected to Qlik Engine");
                ws.OnClose += (sender, e) => Console.WriteLine("WebSocket connection closed");

                // Connect to WebSocket
                ws.Connect();

                // Wait for processing to complete (simplified; adjust for production)
                await Task.Delay(TimeSpan.FromSeconds(10));

                // Close WebSocket
                ws.Close();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error: {ex.Message}");
            }
        }

        private static void OnMessage(object sender, MessageEventArgs e)
        {
            var response = JObject.Parse(e.Data);
            Console.WriteLine($"Received response ID {response["id"]}: {response.ToString(Formatting.Indented)}");
            responses[response["id"].ToString()] = response;

            switch ((int)response["id"])
            {
                case 1: // GetDocList
                    HandleGetDocList(response);
                    break;
                case 2: // OpenDoc
                    HandleOpenDoc(response);
                    break;
                case 3: // CreateSessionObject (SheetList)
                    HandleCreateSessionObjectSheetList(response);
                    break;
                case 4: // GetLayout (SheetList)
                    HandleGetSheetLayout(response);
                    break;
                case 5: // GetObject (Chart)
                    HandleGetObject(response);
                    break;
                case 6: // GetLayout (Chart)
                    HandleGetChartLayout(response);
                    break;
                case 7: // CreateSessionObject (HyperCube)
                    HandleCreateSessionObjectHyperCube(response);
                    break;
                case 8: // GetLayout (HyperCube)
                    HandleGetHyperCubeLayout(response);
                    break;
                case 9: // ExportData
                    HandleExportData(response);
                    break;
            }
        }

        private static void SendRequest(JObject request)
        {
            request["id"] = messageId++;
            ws.Send(request.ToString());
        }

        private static void HandleGetDocList(JObject response)
        {
            foreach (var doc in response["result"]["qDocList"])
            {
                if (doc["qDocName"].ToString() == APP_NAME)
                {
                    var appId = doc["qDocId"].ToString();
                    SendRequest(new JObject
                    {
                        ["jsonrpc"] = "2.0",
                        ["id"] = messageId,
                        ["handle"] = -1,
                        ["method"] = "OpenDoc",
                        ["params"] = new JArray(appId)
                    });
                    break;
                }
            }
        }

        private static void HandleOpenDoc(JObject response)
        {
            appHandle = response["result"]["qReturn"]["qHandle"].ToObject<int>();
            SendRequest(new JObject
            {
                ["jsonrpc"] = "2.0",
                ["id"] = messageId,
                ["handle"] = appHandle,
                ["method"] = "CreateSessionObject",
                ["params"] = new JArray(new JObject
                {
                    ["qInfo"] = new JObject { ["qType"] = "SheetList" },
                    ["qAppObjectListDef"] = new JObject
                    {
                        ["qType"] = "sheet",
                        ["qData"] = new JObject { ["cells"] = "/cells" }
                    }
                })
            });
        }

        private static void HandleCreateSessionObjectSheetList(JObject response)
        {
            sessionHandle = response["result"]["qReturn"]["qHandle"].ToObject<int>();
            SendRequest(new JObject
            {
                ["jsonrpc"] = "2.0",
                ["id"] = messageId,
                ["handle"] = sessionHandle,
                ["method"] = "GetLayout",
                ["params"] = new JArray()
            });
        }

        private static void HandleGetSheetLayout(JObject response)
        {
            var sheets = response["result"]["qLayout"]["qAppObjectList"]["qItems"];
            foreach (var sheet in sheets)
            {
                foreach (var cell in sheet["qData"]["cells"])
                {
                    Console.WriteLine($"Chart ID: {cell["name"]}, Type: {cell["type"]}");
                }
            }
            SendRequest(new JObject
            {
                ["jsonrpc"] = "2.0",
                ["id"] = messageId,
                ["handle"] = appHandle,
                ["method"] = "GetObject",
                ["params"] = new JArray(CHART_ID)
            });
        }

        private static void HandleGetObject(JObject response)
        {
            chartHandle = response["result"]["qReturn"]["qHandle"].ToObject<int>();
            SendRequest(new JObject
            {
                ["jsonrpc"] = "2.0",
                ["id"] = messageId,
                ["handle"] = chartHandle,
                ["method"] = "GetLayout",
                ["params"] = new JArray()
            });
        }

        private static void HandleGetChartLayout(JObject response)
        {
            var hyperCubeDef = response["result"]["qLayout"]["qHyperCubeDef"];
            var dimensions = hyperCubeDef["qDimensions"];
            var measures = hyperCubeDef["qMeasures"];
            var width = dimensions.Count() + measures.Count();
            SendRequest(new JObject
            {
                ["jsonrpc"] = "2.0",
                ["id"] = messageId,
                ["handle"] = appHandle,
                ["method"] = "CreateSessionObject",
                ["params"] = new JArray(new JObject
                {
                    ["qInfo"] = new JObject { ["qType"] = "HyperCube" },
                    ["qHyperCubeDef"] = new JObject
                    {
                        ["qDimensions"] = dimensions,
                        ["qMeasures"] = measures,
                        ["qInitialDataFetch"] = new JArray(new JObject
                        {
                            ["qTop"] = 0,
                            ["qLeft"] = 0,
                            ["qHeight"] = 1000,
                            ["qWidth"] = width
                        })
                    }
                })
            });
        }

        private static void HandleCreateSessionObjectHyperCube(JObject response)
        {
            hypercubeHandle = response["result"]["qReturn"]["qHandle"].ToObject<int>();
            SendRequest(new JObject
            {
                ["jsonrpc"] = "2.0",
                ["id"] = messageId,
                ["handle"] = hypercubeHandle,
                ["method"] = "GetLayout",
                ["params"] = new JArray()
            });
        }

        private static void HandleGetHyperCubeLayout(JObject response)
        {
            var hyperCube = response["result"]["qLayout"]["qHyperCube"];
            var dimensions = hyperCube["qDimensionInfo"].Select(d => d["qFallbackTitle"].ToString()).ToList();
            var measures = hyperCube["qMeasureInfo"].Select(m => m["qFallbackTitle"].ToString() ?? m["qDef"].ToString()).ToList();
            var data = hyperCube["qDataPages"][0]["qMatrix"];

            // Write to CSV
            using (var writer = new StreamWriter(OUTPUT_CSV))
            {
                // Write header
                writer.WriteLine(string.Join(",", dimensions.Concat(measures)));
                // Write data rows
                foreach (var row in data)
                {
                    var rowData = row.Select(cell => cell["qText"].ToString());
                    writer.WriteLine(string.Join(",", rowData));
                }
            }
            Console.WriteLine($"Chart data saved to {OUTPUT_CSV}");

            // Export data as CSV
            SendRequest(new JObject
            {
                ["jsonrpc"] = "2.0",
                ["id"] = messageId,
                ["handle"] = chartHandle,
                ["method"] = "ExportData",
                ["params"] = new JArray("CSV_C")
            });
        }

        private static async void HandleExportData(JObject response)
        {
            var exportUrl = "http://localhost:4848" + response["result"]["qUrl"].ToString();
            using (var client = new HttpClient())
            {
                var responseData = await client.GetAsync(exportUrl);
                var content = await responseData.Content.ReadAsByteArrayAsync();
                File.WriteAllBytes("exported_chart_data.csv", content);
                Console.WriteLine("Exported chart data saved to exported_chart_data.csv");
            }
        }
    }
}










// QlikChartRepository.cs
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Npgsql;

namespace QlikDashboardbackend.Data
{
    public class QlikChartRepository
    {
        private readonly string _connectionString;

        public QlikChartRepository(string connectionString)
        {
            _connectionString = connectionString;
        }

        public async Task SaveChartDataAsync(string chartId, string qText, double? qNum, string layoutJson)
        {
            using var conn = new NpgsqlConnection(_connectionString);
            await conn.OpenAsync();

            var cmd = new NpgsqlCommand(
                @"INSERT INTO QlikChartData (ChartId, QText, QNum, LayoutJson, CreatedAt) 
                  VALUES (@chartId, @qText, @qNum, @layoutJson, NOW())", conn);

            cmd.Parameters.AddWithValue("chartId", chartId);
            cmd.Parameters.AddWithValue("qText", (object)qText ?? DBNull.Value);
            cmd.Parameters.AddWithValue("qNum", (object)qNum ?? DBNull.Value);
            cmd.Parameters.AddWithValue("layoutJson", layoutJson ?? "");

            await cmd.ExecuteNonQueryAsync();
        }

        public async Task<IEnumerable<dynamic>> GetLatestChartDataAsync()
        {
            using var conn = new NpgsqlConnection(_connectionString);
            await conn.OpenAsync();

            var cmd = new NpgsqlCommand(
                "SELECT ChartId, QText, QNum, LayoutJson, CreatedAt FROM QlikChartData ORDER BY CreatedAt DESC", conn);

            using var reader = await cmd.ExecuteReaderAsync();

            var list = new List<dynamic>();
            while (await reader.ReadAsync())
            {
                list.Add(new
                {
                    ChartId = reader["ChartId"].ToString(),
                    QText = reader["QText"].ToString(),
                    QNum = reader["QNum"] != DBNull.Value ? Convert.ToDouble(reader["QNum"]) : (double?)null,
                    LayoutJson = reader["LayoutJson"].ToString(),
                    CreatedAt = Convert.ToDateTime(reader["CreatedAt"])
                });
            }
            return list;
        }
    }
}








// QlikDataExtractor.cs
using System;
using System.Text.Json;
using System.Threading.Tasks;
using QlikDashboardbackend.Data;

namespace QlikDashboardbackend.Services
{
    public class QlikDataExtractor
    {
        private readonly QlikChartRepository _qlikChartRepository;

        public QlikDataExtractor(QlikChartRepository qlikChartRepository)
        {
            _qlikChartRepository = qlikChartRepository;
        }

        /// <summary>
        /// Extracts qText, qNum, and layout JSON from raw Qlik API response and saves to DB.
        /// </summary>
        /// <param name="chartId"></param>
        /// <param name="rawJson"></param>
        public async Task ExtractAndStoreAsync(string chartId, string rawJson)
        {
            if (string.IsNullOrWhiteSpace(rawJson))
                throw new ArgumentException("rawJson cannot be null or empty");

            using var doc = JsonDocument.Parse(rawJson);
            var root = doc.RootElement;

            // Extract layout JSON if present, else empty object
            string layoutJson = root.TryGetProperty("layout", out var layoutElement)
                ? layoutElement.GetRawText()
                : "{}";

            // Extract qMatrix data from qHyperCubeData
            if (!root.TryGetProperty("qHyperCubeData", out var hyperCubeData) ||
                !hyperCubeData.TryGetProperty("qMatrix", out var qMatrix))
            {
                // No hypercube data found, nothing to save
                return;
            }

            foreach (var row in qMatrix.EnumerateArray())
            {
                foreach (var cell in row.EnumerateArray())
                {
                    string qText = cell.TryGetProperty("qText", out var qTextProp)
                        ? qTextProp.GetString()
                        : null;

                    double? qNum = null;
                    if (cell.TryGetProperty("qNum", out var qNumProp) && qNumProp.ValueKind == JsonValueKind.Number)
                    {
                        qNum = qNumProp.GetDouble();
                    }

                    // Save extracted data point to DB
                    await _qlikChartRepository.SaveChartDataAsync(chartId, qText, qNum, layoutJson);
                }
            }
        }
    }
}







using QlikDashboardbackend.Data;
using QlikDashboardbackend.Services;
using System.Collections.Generic;
using System.Security.Cryptography.X509Certificates;
using System.Threading.Tasks;

namespace QlikDashboardbackend.Services
{
    public class QlikProcessor
    {
        private readonly QlikChartRepository _repository;
        private readonly QlikDataExtractor _extractor;

        public QlikProcessor(string connectionString)
        {
            _repository = new QlikChartRepository(connectionString);
            _extractor = new QlikDataExtractor(_repository);
        }

        public async Task<List<object>> RunAsync()
        {
            string appId = "your-app-id";
            List<string> objectIds = new List<string> { "id1", "id2", "id3" };

            var clientCert = new X509Certificate2("path-to-cert.pfx", "cert-password");
            var handler = new ClientWebSocketHandler(clientCert, "UserDirectory=INTERNAL; UserId=sa_engine");

            List<object> results = new List<object>();

            using var ws = await handler.ConnectAsync(new Uri($"wss://your-qlik-server:4747/app/{appId}"));

            foreach (var objectId in objectIds)
            {
                string rawJson = await QlikCert.SendEngineRequest(ws, appId, objectId);

                // Save parsed data to DB
                await _extractor.ExtractAndStoreAsync(objectId, rawJson);

                results.Add(rawJson); // or some summary data if needed
            }

            return results;
        }
    }
}

